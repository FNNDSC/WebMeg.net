// Function to add the event in a group
function addEvent(group) {
	// Check if user has defined an event type
	var MF=MEGFIFF;
	if (MF.eventNames.length==0) {
		alert("No event type exists!! Please create an event type first");
		return;
	}
	
	// Check if user has selected an event group
	if (MF.currentEventGroup.length==0) {
		alert("No event type selected!! Select event type and then add event.");
		return;
	}
	
	var currentGroupIndex=MF.eventNames.indexOf(MF.currentEventGroup);
	
	// Check if event with same type and time exists
	if (MF.eventIdGroup[currentGroupIndex] > 0) {
		for (var i=0;i<MF.eventTimes[currentGroupIndex].length;i++) {
			if (Math.abs(MF.currentTime-MF.eventTimes[currentGroupIndex][i])<0.00001) {
				return;
			}
		}
	}
	MF.eventIdGroup[currentGroupIndex]++;
	
	// Add unordered list if there is no event for that type else just add event
	if (MF.eventTimes[currentGroupIndex].length==0) $("#"+MF.currentEventGroup).append('<ul style="width:100px;padding"><li id="'+MF.currentEventGroup  +'_'+MF.eventIdGroup[currentGroupIndex]+'" style="background-color:#8A2EB2;width:100px;left:0;height:28px" onclick="javascript:selectEvent(this.id)"><a href="#"><span style="color:#a9a9a9;">'+MF.currentTime+'s'+'</span></a></li></ul>');
	else $("#"+MF.currentEventGroup+" li:eq("+(MF.eventTimes[currentGroupIndex].length-1)+")").after('<li id="'+MF.currentEventGroup+'_'+MF.eventIdGroup[currentGroupIndex]+'" style="background-color:#8A2EB2;width:100px;left:0;height:28px" onclick="javascript:selectEvent(this.id)"><a href="#"><span style="color:#a9a9a9;">'+MF.currentTime+'s'+'</span></a></li>');	
	MF.eventTimes[currentGroupIndex][MF.eventTimes[currentGroupIndex].length]=MF.currentTime;
	MF.currentEvent=MF.currentEventGroup+'_'+MF.eventIdGroup[currentGroupIndex];
	
	if(!group) chart.addSeries({type : 'flags',data:[{x : MF.currentTime*MF.sfreq,title : MF.currentEventGroup}],shape:'squarepin',states:{hover:{fillColor:'#395C84'}},y:-chart.plotHeight,color: '#5F86B3'});
	
	var eventList=$('#'+MF.currentEventGroup+' > ul > li');
	// Switch colors of other events to default background
	for (var i=0;i<eventList.length;i++) {
		if (MF.currentEvent != eventList[i].id) $("#"+eventList[i].id).css('background-color',"#2d2d2d");
	}
	sortEvents(); // Reorder the menu
};

//  Sort the events in ascending order and reorder the menu accordingly
function sortEvents() {
	var MF=MEGFIFF;
	var currentGroupIndex=MF.eventNames.indexOf(MF.currentEventGroup);
	var eventsSort=new Array(MF.eventTimes[currentGroupIndex].length);
	for (var i=0;i<eventsSort.length;i++) eventsSort[i]=MF.eventTimes[currentGroupIndex][i];
	
	var tmp=new Array(eventsSort.length);
	var myList=$('#'+MF.currentEventGroup+' li');
	
	MF.eventTimes[currentGroupIndex].sort(function(a,b){return a-b});
	
	var ul=document.getElementById(MF.currentEventGroup).children[1];
	var sortIndex;
	for (var i=0;i<eventsSort.length;i++) {
		sortIndex=eventsSort.indexOf(MF.eventTimes[currentGroupIndex][i]);
		tmp[i]=myList[sortIndex];
	}
	
	for (var i=0;i<eventsSort.length;i++) ul.appendChild(tmp[i]);
}
	

/* This function is to add the event by the user and update the list on the menu bar
 */
function addEventGroup(e, addGroup) {
	var MF=MEGFIFF;
	var check=checkData(); if (check==0) return;

	
	// Prompt the user for new event name
	if (arguments.length==1) var addGroup=prompt("Enter new event type","Event"+MF.numEvent);
	
	if (addGroup==null) return;
	
	if (addGroup=="" || addGroup.match(/^[0-9a-zA-Z]+$/)==null)  {
		alert("Empty name or contains special characters. Try naming again")
		return;
	}
	
	// If same name exists, complain to the user 
	for (var i=0;i<MF.numEvent;i++) {
		if (addGroup==MF.eventNames[i]) {
			if (arguments.length==1) alert ('Same event name exists!! Choose a different name.')
			return;
		}
	}
	var numLi=$("#eventAddGroup li").length;
	// Add event type to the list
	$("#eventAddGroup > ul").append('<li id="'+addGroup+'" style="background-color:#8A2EB2;width:180px;left:0;height:28px" onclick="javascript:selectGroup(this.id)"><a href="#"><span style="color:#a9a9a9;">'+addGroup+'</span></a></li>')
	
	// Update event information
	MF.numEvent++;
	MF.eventNames[MF.numEvent-1]=addGroup;
	MF.eventTimes[MF.numEvent-1]=new Array();
	MF.eventIdGroup[MF.numEvent-1]=0;
	MF.currentEventGroup=addGroup;
	
	// Switch the background color of the rest of event types
	for (var i=0;i<MF.numEvent;i++ ) {
		if (MF.eventNames[i] != addGroup) $("#"+MF.eventNames[i]).css('background-color',"#2d2d2d");
	}
	return;
}              

//Function to delete a event in the group

function deleteEvent() {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;
	// Check if user has defined an event type
	if (MF.eventNames.length==0) {
		alert("No event type exists!! Please create an event type first");
		return;
	}
	
	// Check if user has selected an event group
	if (MF.currentEventGroup.length==0) {
		alert("No event type selected!! Select event type and the event to be deleted.");
		return;
	}
	
	if (MF.currentEvent.length==0) {alert("No event selected!! Select the event to be deleted.");}
	
	var currentGroupIndex=MF.eventNames.indexOf(MF.currentEventGroup);
	var eventTime=$('#'+MF.currentEvent).text();
	eventTime=parseFloat(eventTime.match(/\d+\.?\d*/g));
	var belongToGroup=MF.eventTimes[currentGroupIndex].indexOf(eventTime);
	if(belongToGroup==-1) {alert('Selected event does not belong to selected group.\n To delete select the group corresponding to event');return;}
	var sureDelete=confirm('Delete '+MF.currentEventGroup+' : '+eventTime+' s');
	
	if (sureDelete) {
		$("#"+MF.currentEvent).remove();
		var index=MF.eventTimes[currentGroupIndex].indexOf(eventTime);
		MF.eventTimes[currentGroupIndex].splice(index, 1);
		var tmp,tmp1=chart.series.length,tmp2=chart.series,tmp3;
		for(var i=0;i<tmp1;i++){
			if (tmp2[i].processedXData.length==1) {
				tmp=tmp2[i].processedXData/MF.sfreq;
				tmp=tmp.toFixed(3);
				if(tmp==eventTime) {tmp3=i;break;}
			}
		}
		chart.series[tmp3].remove();
	}
	return;
}

//Function to delete a particular event group

function deleteEventGroup() {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;

	// Check if user has defined an event type
	if (MF.eventNames.length==0) {
		alert("No event type exists to delete!!");
		return;
	}
	
	// Check if user has selected an event group to delete
	if (MF.currentEventGroup.length==0) {
		alert("No group selected. Please select the group to delete");
		return;
	}
	
	var indexEvent=MF.eventNames.indexOf(MF.currentEventGroup);
	
	// Ask for confirmation
	confirmDelete=confirm("Delete "+MF.currentEventGroup+" group containing "+MF.eventTimes[indexEvent].length+" events?");
	if(confirmDelete) {
		$("#"+MF.currentEventGroup).remove();
		// Update values after deletion of group
		MF.eventNames.splice(indexEvent, 1);
		MF.eventTimes.splice(indexEvent, 1);
		MF.numEvent--;
		MF.currentEventGroup=[];
		MF.currentEvent=[];
	}
	chart.destroy();
	plotData_highChart(MEG_data);
	chart.xAxis[0].setExtremes(MF.startPlot,MF.endPlot);	
	return;		
}

/* This function is used to save the events defined by user
 *Author : Chiran Doshi 
 */
function saveEvents() {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;

	// Check if user has defined an event type
	if (MF.eventNames.length==0) {
		alert("No events exist!! Please define events first");
		return;
	}
	
	var saveTxt="";
	saveTxt="Sampling frequency\t"+MF.sfreq+"\r\n";
	
	for (var i=0;i<MF.eventNames.length;i++) {
		for (var j=0;j<MF.eventTimes[i].length;j++) 
			saveTxt=saveTxt+MF.eventNames[i]+"\t"+MF.eventTimes[i][j]+"\r\n";
	}
	
	uriContent="data:application/octet-stream,"+encodeURIComponent(saveTxt);
	newWindow=window.open(uriContent);
}

/* Function used to select a particular event
 */

function selectEvent(evt) {
	var MF=MEGFIFF;
	// Return if selected event is clicked
	if (evt==MF.currentEvent) return;
	var group=$('#'+evt).parent().parent().attr('id');
	var eventList=$('#'+group+' > ul > li');
	
	// Switch colors of other events to default background
	for (var i=0;i<eventList.length;i++) {
		if (evt != eventList[i].id) {
			$("#"+eventList[i].id).css('background-color',"#2d2d2d");
		}
		else {
			$("#"+eventList[i].id).css('background-color','#8A2EB2');
		}
	}
	MF.currentEvent=evt;
	
	// Adjust display based on event clicked
	var timeClick=parseFloat($('#'+evt).text().match(/\d+\.?\d*/g))*MF.sfreq;
	var disLen=chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min;

	if ((timeClick >= MF.startPlot && timeClick >= MF.endPlot) || (timeClick <= MF.startPlot && timeClick <= MF.endPlot)) {
		MF.startPlot=Math.round(timeClick)-disLen/2.0;
		if (MF.startPlot<0) MF.startPlot=0;
		MF.endPlot=MF.startPlot+disLen;
		chart.xAxis[0].setExtremes(MF.startPlot,MF.endPlot);
	}
}

/* Function to select the group on mouse click 
 */
function selectGroup(evt) {
	var MF=MEGFIFF;
	// Return if the current 
	if (MF.currentEventGroup==evt) return;
	
	MF.currentEventGroup=evt;
	$("#"+MF.currentEventGroup).css('background-color',"#8A2EB2");
	
	// Switch the background color of the rest of event types
		for (var i=0;i<MF.numEvent;i++ ) {
			if (MF.eventNames[i] != MF.currentEventGroup) $("#"+MF.eventNames[i]).css('background-color',"#2d2d2d");
		}
	return
}

function addLoadEvents(strData,strDelimiter) {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;

		if (strData.length==0) {
			alert('Empty file!! Please load file containing events');
			return;
		}
		var indexLine, lineString, count=0, indexTab, evtName;
		do {
			count++;
			indexLine=strData.indexOf('\n');
			lineString=strData.substr(0,indexLine);
			if (count==1) {
				sfreq=parseFloat(lineString.match(/\d+\.?\d*/g));
				if (sfreq != MF.sfreq) {
					alert('Loaded events do not belong to the data due to differing sampling rates');
					return;
				}
			}
			else {
				indexTab=strData.indexOf('\t');
				addGroup= strData.substr(0,indexTab);
				if (!(addGroup=="" || addGroup.match(/^[0-9a-zA-Z]+$/)==null))  {
					addEventGroup('',addGroup)
					MF.currentTime=parseInt(parseFloat(lineString.substr(indexTab+1,indexLine).match(/\d+\.?\d*/g))*1000)/1000;
					addEvent(true);
				}

			}
			strData=strData.substr(indexLine+1, strData.length);
		} while (indexLine != -1);
		redrawFlags();
}

function setTrgParam() {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;

	$('div#evtDlg').dialog('open');
	 var opt,op1;
	for (var i=0;i<MF.allChs.length;i++) {
		opt=document.createElement("option");
		opt1=document.createElement("option");
		document.getElementById("chList1").options.add(opt);
		opt.text=MF.allChs[i];
		document.getElementById("chList2").options.add(opt1);
		opt1.text=MF.allChs[i];
	}
	
}

function evtDetect() {
	$('div#evtDlg').dialog('close');
	var MF=MEGFIFF;

	var trg1;
	var cnt1=0,cnt3=0;
	if (document.getElementsByName('trg1')[0].checked) {
		MF.trg1=prompt("Enter name of event on channel 1");
		trg1=detectEdge(finalData[MF.allChs.indexOf(document.getElementById('chList1').value)]);
		MF.evt1=[];
	}
	var trg2;
	if (document.getElementsByName('trg2')[0].checked) {
		MF.trg2=prompt("Enter name of event on channel 2")
		trg2=detectEdge(finalData[MF.allChs.indexOf(document.getElementById('chList2').value)]);
		MF.evt2=[];
	}
	
	if (trg1 != undefined && trg2 != undefined) {
		MF.evt3=[];
		MF.trg3=prompt("Enter name of event on channels 1 and 2")
		var fnd=0;
		for (var i=0;i<trg1.length;i++) {
			fnd=0;
			var tmp=trg2.length;
			for (var j=0;j<tmp;j++) {
				if (trg1[i] > trg2[j]-10 && trg1[i]<trg2[j]+10) {
					trg2.splice(j,1);
					MF.evt3[cnt3]=trg1[i];
					cnt3++;
					fnd=1;
					break;
				}
				
			}
			if (fnd==0) {
				MF.evt1[cnt1]=trg1[i];
				cnt1++;
			}	
		}
		MF.evt2=trg2;
		addDetectedEvent(MF.trg1,MF.evt1);
		addDetectedEvent(MF.trg2,MF.evt2);
		if (cnt3 > 0) addDetectedEvent(MF.trg3,MF.evt3);
	}
	else if(trg1 != undefined) {
		MF.evt1=trg1;
		addDetectedEvent(MF.trg1,MF.evt1);
	}
	else {
		MF.evt2=trg2;
		addDetectedEvent(MF.trg2,MF.evt2);
	}
	redrawFlags();
}

function addDetectedEvent(evtName,evtTime) {
	var MF=MEGFIFF;
	addEventGroup('',evtName);
	var tmp=evtTime.length;
	var sfreq=MF.sfreq;
	for (var i=0;i<tmp;i++) {
		MF.currentTime=parseInt(evtTime[i]*1000/sfreq)/1000;
		addEvent(true);
	}
}

function detectEdge(sig) {
	var r=calParams(sig);
	var thres=parseFloat(document.getElementsByName('thresVal')[0].value);
	var lengthSig=sig.length;
	var zscr=new Array(lengthSig-1);
	var index=new Array();
	var numIndex=0;
	for (var i=0;i<lengthSig-1;i++) {
		zscr[i]= (sig[i+1]-sig[i]-r.mean)/r.deviation;
		if (Math.abs(zscr[i]) > thres) {
			index[numIndex]=i+1;
			numIndex++;
		}
	}
	
	var temp=index.length;
	var index1=new Array();
	index1[0]=index[0];
	numIndex=1;
	var temp1;
	for (var i=1;i<temp-1;i++) {
		temp1=index[i+1]-index[i];
		if(temp1 > 20) {
			index1[numIndex]=index[i+1];
			numIndex++;
		}
	}
	return index1;
}

function calParams(a) {
	var r={mean: 0, variance: 0, deviation: 0};
	var t=a.length;
	for(var m, s=0, l=t; l--; s += a[l]);
	for(m=r.mean=s/t, l=t, s=0; l--; s += Math.pow(a[l]-m, 2));
	r.deviation=Math.sqrt(r.variance=s/(t-1))
	return r;
}

function addDelay() {
	var check=checkData(); if (check==0) return;
	var MF=MEGFIFF;
	var numEv=MF.eventNames.length;
	if (numEv==0) {alert('No events created yet');return;}
	var delay=prompt("Enter delay in ms for adding to all events",0);
	delay=parseInt(parseFloat(delay))/1000;
	var currentGroupIndex=MF.eventNames.indexOf(MF.currentEventGroup);
	if (delay==0) return;
	
	for (var i=0;i<numEv;i++) {
		MF.currentEventGroup=MF.eventNames[i];
		var tmp=MF.eventTimes[i].length;
		for (var j=0;j<tmp;j++) {
			MF.currentTime=MF.eventTimes[i][j];
			$("#"+MF.currentEventGroup+"_"+(j+1)).remove();
			MF.eventTimes[i][j] =Math.round((MF.eventTimes[i][j]+delay)*1000)/1000;
			MF.currentTime=MF.eventTimes[i][j];
			MF.eventTimes[i][j]=0;
			MF.eventTimes[i][j]=MF.currentTime;
		}
	}
	
	for (var i=0;i<numEv;i++) {
		var tmp=clone(MF.eventTimes[i]);
		var tmp1=tmp.length;
		
		MF.currentEventGroup=MF.eventNames[i];
		MF.eventTimes[i]=[];
		for(var j=0;j<tmp1;j++){
			MF.currentTime=tmp[j];
			addEvent(true);
		}
	}
	chart.destroy();
	plotData_highChart(MEG_data);
	chart.xAxis[0].setExtremes(MF.startPlot,MF.endPlot);
	redrawFlags();
}